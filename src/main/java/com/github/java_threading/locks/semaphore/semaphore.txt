Semaphore
=========

WHAT IS IT?
-----------
A Semaphore maintains a set of permits. Threads must acquire permits to proceed
and release them when done.

Unlike locks (binary - locked/unlocked), semaphores can have MULTIPLE permits.

Think of it as a bouncer at a club with limited capacity:
- acquire() = enter (wait if full)
- release() = exit (let someone else in)


WHEN TO USE?
------------
- Limiting concurrent access to a resource (connection pools, rate limiting)
- Resource pooling (database connections, thread pools)
- Bounded producer-consumer
- Binary semaphore as mutex (1 permit)


KEY CHARACTERISTICS
-------------------
1. Permit count can be > 1 (unlike locks)
2. NOT reentrant (each acquire consumes a permit, even same thread)
3. Supports fairness mode (FIFO ordering)
4. ANY thread can release (not just the one that acquired)
5. Can release more permits than initially available!
6. No ownership tracking (unlike locks)


BASIC USAGE
-----------
// Create semaphore with 3 permits
Semaphore semaphore = new Semaphore(3);

// Acquire permit (blocks if none available)
semaphore.acquire();
try {
    // Access shared resource
} finally {
    semaphore.release();  // Return permit
}


KEY METHODS
-----------
Semaphore sem = new Semaphore(permits);
Semaphore sem = new Semaphore(permits, true);  // Fair

// Acquire
sem.acquire()                      // Block until permit available
sem.acquire(n)                     // Acquire n permits
sem.acquireUninterruptibly()       // Block, ignore interrupts
sem.tryAcquire()                   // Non-blocking, returns boolean
sem.tryAcquire(timeout, unit)      // With timeout
sem.tryAcquire(n, timeout, unit)   // Multiple permits with timeout

// Release
sem.release()                      // Return one permit
sem.release(n)                     // Return n permits

// Info
sem.availablePermits()             // Current available permits
sem.drainPermits()                 // Acquire all available, return count
sem.hasQueuedThreads()             // Are threads waiting?
sem.getQueueLength()               // Approximate waiting threads
sem.isFair()                       // Is fair mode enabled?


BINARY SEMAPHORE (MUTEX)
------------------------
Semaphore with 1 permit acts like a lock:

Semaphore mutex = new Semaphore(1);

mutex.acquire();
try {
    // Critical section
} finally {
    mutex.release();
}

IMPORTANT: Unlike ReentrantLock, binary semaphore is NOT reentrant!
Same thread acquiring twice will BLOCK (not deadlock, just wait forever).


USAGE
--------
CONNECTION POOL PATTERN
RATE LIMITING PATTERN


FAIR VS UNFAIR MODE
-------------------
Unfair (default): new Semaphore(n) or new Semaphore(n, false)
- Better throughput
- Permits may be given to any waiting or arriving thread
- May cause starvation

Fair: new Semaphore(n, true)
- Threads acquire permits in FIFO order
- Prevents starvation
- Lower throughput


SEMAPHORE VS LOCK
-----------------
| Feature              | Lock             | Semaphore          |
|----------------------|------------------|--------------------|
| Permits              | 1 (binary)       | N (configurable)   |
| Reentrant            | Yes (Reentrant*) | NO                 |
| Owner tracking       | Yes              | NO                 |
| Who can release      | Owner only       | Any thread         |
| Use case             | Mutual exclusion | Resource limiting  |


SEMAPHORE VS CountDownLatch
---------------------------
| Feature              | Semaphore        | CountDownLatch     |
|----------------------|------------------|--------------------|
| Permits go up/down   | Both (reusable)  | Only down (once)   |
| Reset                | Yes              | NO                 |
| Use case             | Resource control | One-time gate      |


THREAD SAFETY NOTE
------------------
Semaphore itself is thread-safe, but the resource it guards may not be.
The semaphore only limits concurrent access; it doesn't provide
synchronization for the actual resource operations.


INTERRUPTED EXCEPTION
---------------------
When a thread is waiting on acquire(), it can be interrupted by another thread.
This throws InterruptedException and the thread does NOT get the permit.

WHY DOES IT HAPPEN?
- Another thread called interrupt() on the waiting thread
- Thread pool shutdown (shutdownNow() interrupts waiting tasks)
- Timeout mechanisms that use interruption
- Cancellation of tasks

THREE WAYS TO HANDLE:

1. PROPAGATE (Recommended for most cases)
   - Let the caller decide what to do
   - Preserves the interrupt signal

   public void doWork() throws InterruptedException {
       semaphore.acquire();  // Let exception propagate
       try {
           // work
       } finally {
           semaphore.release();
       }
   }

2. RESTORE INTERRUPT FLAG (When you can't throw)
   - Catch it, clean up, restore the flag
   - Allows code higher up to detect interruption

   @Override
   public void run() {  // Runnable can't throw checked exceptions
       try {
           semaphore.acquire();
           try {
               // work
           } finally {
               semaphore.release();
           }
       } catch (InterruptedException e) {
           Thread.currentThread().interrupt();  // Restore flag!
           // Optional: log or handle gracefully
       }
   }

3. USE acquireUninterruptibly() (Rare cases)
   - Ignores interrupts, keeps waiting
   - Use only when you MUST complete the operation

   semaphore.acquireUninterruptibly();  // Won't throw
   try {
       // critical work that must happen
   } finally {
       semaphore.release();
   }

COMMON MISTAKE - SWALLOWING THE INTERRUPT:

   // BAD - Don't do this!
   try {
       semaphore.acquire();
   } catch (InterruptedException e) {
       // Empty catch or just logging - interrupt is lost!
   }

This breaks the cooperative cancellation model. Always either:
- Propagate the exception, OR
- Restore the interrupt flag with Thread.currentThread().interrupt()


RELEASE IN FINALLY BLOCK
------------------------
IMPORTANT: Only release if you successfully acquired!

   // WRONG - may release without acquiring
   try {
       semaphore.acquire();
       // work
   } catch (InterruptedException e) {
       Thread.currentThread().interrupt();
   } finally {
       semaphore.release();  // BUG: releases even if acquire failed!
   }

   // CORRECT - track acquisition
   boolean acquired = false;
   try {
       semaphore.acquire();
       acquired = true;
       // work
   } catch (InterruptedException e) {
       Thread.currentThread().interrupt();
   } finally {
       if (acquired) {
           semaphore.release();
       }
   }

   // OR - structure code properly
   try {
       semaphore.acquire();
   } catch (InterruptedException e) {
       Thread.currentThread().interrupt();
       return;  // Exit early, never reached the work
   }
   try {
       // work
   } finally {
       semaphore.release();  // Safe: only reached if acquired
   }

